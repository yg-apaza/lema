package lema;

import java.util.ArrayList;

parser code
{:
    public Nodo raiz;
    
    public void report_error(String message, Object info)
    {   
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol)
        {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0)
            {                
                m.append(" en la lÃ­nea " + (s.left + 1));   

                if (s.right >= 0)                    
                    m.append(", columna " + (s.right + 1));
            }
        }

        m.append(" : " + message);

        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info)
    {
        report_error(message, info);
        System.exit(1);
    }

    public Nodo getAST()
    {
        return raiz;
    }
:};


/* DECLARACION DE TERMINALES */

terminal Nodo pr_const, pr_vacio, pr_entero, pr_real, pr_cadena, 
par_ab, par_ce, cor_ab, cor_ce, ll_ab, ll_ce, 
mas, menos, prod, div, mod, transp, inv, incr, decr, 
ident, dif, menor, mayor, menor_igual, mayor_igual, y, o, neg, igual, 
pr_suma, pr_resta, pr_prod, pr_transp, pr_inv, 
a_suma, a_resta, a_prod, a_div, a_mod, 
sig_int, sig_pun, 
octa_e, octa_r, hexa_e, hexa_r, numero, real, cadena, 
pr_leer, pr_mostrar, 
pr_principal,
pr_si, pr_sino, pr_mientras, pr_hacer, pr_para, pr_selector, pr_saltar, pr_caso, pr_default, pr_retornar,
punto_coma, coma,
id, premas, premenos,
err;




/* DECLARACION DE NO TERMINALES */

non terminal Nodo PROGRAMA, 
PROGRAMAPRINCIPAL,

EXPRESION, EXPGEN,
SENTENCIA,

DECLARACIONFUNCION,
DECSIMPLE, DECVECT, DECMAT, 

DECCON,
DECCAD,
DEFINICIONPROTOTIPO,

ASIGNACION, LLAMADAFUNCION, 
CONDICIONALHACERMIENTRAS, CONDICIONALMIENTRAS, CONDICIONALPARA, CONDICIONALSI, 
SENTSELECTOR, SENTDEFECTO,
SENTCASO, 

ESCRITURA, LECTURA, 
MATRIZ, VECTOR,
INDICE, INI, ACT,
CONDICIONAL, 

OPERANDOENTERO,
OPERADORFUNCION, OPERADORCOND, 
OPERANDO,
TIPONUMERO, TIPOVARIABLEFUNCION;

non terminal ArrayList<Nodo> BLOQUE, DEFINICIONVARIABLE, DEFINICIONVARIABLECAB, DECLARACION,  DECLARACIONCON, DECENTERO, DECREAL, DECALL, ARGUMENTO,
PARAMETROBINARIO, PARAMETROUNARIO, NELEMENTO, NVECTOR, DECCADALL, DECCONALL, PARAMETROPROTOTIPO, NSENTENCIA, CONTROLADOR, NCASO, DEFINICIONFUNCION, DECLARACIONFUNCIONCABECERA, PARAMETRO;

/* PRECEDENCIA */

precedence left y, o;
precedence left ident, dif, menor, mayor, menor_igual, mayor_igual;
precedence left mas, menos;
precedence left mod;
precedence left prod, div;
precedence left transp, inv;
precedence right incr, decr, neg;
precedence right premas, premenos;


precedence nonassoc pr_const; 
precedence nonassoc pr_vacio; 
precedence nonassoc pr_entero; 
precedence nonassoc pr_real; 
precedence nonassoc pr_cadena; 
 
precedence nonassoc par_ab; 
precedence nonassoc par_ce; 
precedence nonassoc cor_ab; 
precedence nonassoc cor_ce;
precedence nonassoc ll_ab; 
precedence nonassoc ll_ce; 
 
precedence nonassoc pr_suma; 
precedence nonassoc pr_resta; 
precedence nonassoc pr_prod; 
precedence nonassoc pr_transp; 
precedence nonassoc pr_inv; 
 
precedence nonassoc igual; 
precedence nonassoc a_suma; 
precedence nonassoc a_resta; 
precedence nonassoc a_prod; 
precedence nonassoc a_div; 
precedence nonassoc a_mod; 
precedence nonassoc sig_int; 
precedence nonassoc sig_pun; 
 
precedence nonassoc octa_e; 
precedence nonassoc octa_r; 
precedence nonassoc hexa_e; 
precedence nonassoc hexa_r; 
precedence nonassoc numero; 
precedence nonassoc real; 
precedence nonassoc cadena; 

precedence nonassoc pr_leer; 
precedence nonassoc pr_mostrar; 
precedence nonassoc punto_coma; 
precedence nonassoc coma; 
precedence nonassoc pr_retornar; 
precedence nonassoc pr_si; 
precedence nonassoc pr_sino; 
precedence nonassoc pr_mientras; 
precedence nonassoc pr_hacer; 
precedence nonassoc pr_para; 
precedence nonassoc pr_selector; 
precedence nonassoc pr_saltar; 
precedence nonassoc pr_caso; 
precedence nonassoc pr_default; 
precedence nonassoc pr_principal; 
precedence nonassoc id; 
 
start with PROGRAMA;


PROGRAMA  ::= DEFINICIONVARIABLECAB:dvc PROGRAMAPRINCIPAL:pp
{:
    Nodo cab = new Nodo(accion.cabecera, accion.acciones[accion.cabecera], 1, 1, dvc, false);
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(cab);
    hijos.add(pp);
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMA  ::= DEFINICIONVARIABLECAB:dvc PROGRAMAPRINCIPAL:pp DEFINICIONFUNCION:df
{:
    Nodo cab = new Nodo(accion.cabecera, accion.acciones[accion.cabecera], 1, 1, dvc, false);
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(cab);
    hijos.add(pp);
    
    hijos.add(new Nodo(accion.defFuncion, accion.acciones[accion.defFuncion], 1, 1, df, false));
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMA  ::= PROGRAMAPRINCIPAL:pp DEFINICIONFUNCION:df
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(pp);
    hijos.add(new Nodo(accion.defFuncion, accion.acciones[accion.defFuncion], 1, 1, df, false));
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMA ::= PROGRAMAPRINCIPAL:pp
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(pp);
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMAPRINCIPAL  ::= pr_principal par_ab par_ce BLOQUE:b
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    RESULT = new Nodo(accion.programaPrincipal, accion.acciones[accion.programaPrincipal], 1, 1, b, false);
:};

DEFINICIONVARIABLECAB  ::= DECLARACION:d
{:
    RESULT = d;
:};

DEFINICIONVARIABLECAB  ::= DECLARACIONCON:c
{:
    RESULT = c;
:};

DEFINICIONVARIABLECAB  ::= DEFINICIONPROTOTIPO:p
{:
    ArrayList<Nodo> dp = new ArrayList<Nodo>();
    dp.add(p);
    RESULT = dp;
:};

DEFINICIONVARIABLECAB  ::= DECLARACION:d DEFINICIONVARIABLECAB:r
{:
    d.addAll(r);
    RESULT = d;
:};

DEFINICIONVARIABLECAB  ::= DECLARACIONCON:c DEFINICIONVARIABLECAB:r
{:
    c.addAll(r);
    RESULT = c;
:};

DEFINICIONVARIABLECAB  ::= DEFINICIONPROTOTIPO:p DEFINICIONVARIABLECAB:r
{:
    r.add(0, p);
    RESULT = r;
:};

DEFINICIONPROTOTIPO	::= pr_entero:t id:i par_ab PARAMETROPROTOTIPO:param par_ce punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);

    Nodo parametros = new Nodo(accion.parametroProt, accion.acciones[accion.parametroProt], 1, 1, param, false);
    hijos.add(parametros);
    RESULT = new Nodo(accion.declaracionProt, accion.acciones[accion.declaracionProt], 1, 1, hijos, false);
:};


DEFINICIONPROTOTIPO	::= pr_entero:t id:i par_ab par_ce punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    Nodo parametros = new Nodo(accion.parametroProt, accion.acciones[accion.parametroProt], 1, 1, param, false);
    hijos.add(parametros);
    RESULT = new Nodo(accion.declaracionProt, accion.acciones[accion.declaracionProt], 1, 1, hijos, false);
:};

DEFINICIONPROTOTIPO	::= pr_real:t id:i par_ab PARAMETROPROTOTIPO:param par_ce punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    Nodo parametros = new Nodo(accion.parametroProt, accion.acciones[accion.parametroProt], 1, 1, param, false);
    hijos.add(parametros);
    RESULT = new Nodo(accion.declaracionProt, accion.acciones[accion.declaracionProt], 1, 1, hijos, false);
:};

DEFINICIONPROTOTIPO	::= pr_real:t id:i par_ab par_ce punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    Nodo parametros = new Nodo(accion.parametroProt, accion.acciones[accion.parametroProt], 1, 1, param, false);
    hijos.add(parametros);
    RESULT = new Nodo(accion.declaracionProt, accion.acciones[accion.declaracionProt], 1, 1, hijos, false);
:};

DEFINICIONPROTOTIPO	::= pr_vacio:t id:i par_ab PARAMETROPROTOTIPO:param par_ce punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    Nodo parametros = new Nodo(accion.parametroProt, accion.acciones[accion.parametroProt], 1, 1, param, false);
    hijos.add(parametros);
    RESULT = new Nodo(accion.declaracionProt, accion.acciones[accion.declaracionProt], 1, 1, hijos, false);
:};

DEFINICIONPROTOTIPO	::= pr_vacio:t id:i par_ab par_ce punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    Nodo parametros = new Nodo(accion.parametroProt, accion.acciones[accion.parametroProt], 1, 1, param, false);
    hijos.add(parametros);
    RESULT = new Nodo(accion.declaracionProt, accion.acciones[accion.declaracionProt], 1, 1, hijos, false);
:};

PARAMETROPROTOTIPO  ::= TIPONUMERO:t coma PARAMETROPROTOTIPO:param
{:
    param.add(0, t);
    RESULT = param;
:};

PARAMETROPROTOTIPO  ::= TIPONUMERO:t INDICE:i1 INDICE:i2 coma PARAMETROPROTOTIPO:param
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i1);
    hijos.add(i2);
    Nodo n = new Nodo(accion.parametroProtMat, accion.acciones[accion.parametroProtMat], 1, 1, hijos, false);
    
    param.add(0, n);
    RESULT = param;
:};

PARAMETROPROTOTIPO  ::= TIPONUMERO:t INDICE:i1 coma PARAMETROPROTOTIPO:param
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i1);
    Nodo n = new Nodo(accion.parametroProtVec, accion.acciones[accion.parametroProtVec], 1, 1, hijos, false);
    
    param.add(0, n);
    RESULT = param;
:};

PARAMETROPROTOTIPO  ::= TIPONUMERO:t INDICE:i1 INDICE:i2 
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();

    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i1);
    hijos.add(i2);
    Nodo n = new Nodo(accion.parametroProtMat, accion.acciones[accion.parametroProtMat], 1, 1, hijos, false);
    
    param.add(n);
    RESULT = param;
:};

PARAMETROPROTOTIPO  ::= TIPONUMERO:t INDICE:i1
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();

    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i1);
    Nodo n = new Nodo(accion.parametroProtVec, accion.acciones[accion.parametroProtVec], 1, 1, hijos, false);
    
    param.add(n);
    RESULT = param;
:};

PARAMETROPROTOTIPO  ::= TIPONUMERO:t
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    param.add(t);
    RESULT = param;
:};


DEFINICIONFUNCION  ::= DECLARACIONFUNCION:f DEFINICIONFUNCION:df
{:
    df.add(0, f);
    RESULT = df;
:};

DEFINICIONFUNCION  ::= DECLARACIONFUNCION:f 
{:
    ArrayList<Nodo> df = new ArrayList<Nodo>();
    df.add(f);
    RESULT = df;
:};



DECLARACION  ::= pr_entero:t DECENTERO:e
{:
    for(int i = 0; i < e.size(); i++)
        e.get(i).getHijos().add(0, t);

    RESULT = e;
:};

DECLARACION  ::= pr_real:t DECREAL:r
{:
    for(int i = 0; i < r.size(); i++)
        r.get(i).getHijos().add(0, t);

    RESULT = r;
:};

DECLARACION  ::= pr_cadena:t DECCADALL:c punto_coma
{:
    for(int i = 0; i < c.size(); i++)
        c.get(i).getHijos().add(0, t);
    
    RESULT = c;
:};


DECLARACIONCON  ::= pr_const pr_entero:t DECCONALL:e punto_coma 
{:
    for(int i = 0; i < e.size(); i++)
        e.get(i).getHijos().add(0, t);

    RESULT = e;
:};

DECLARACIONCON  ::= pr_const pr_real:t DECCONALL:r punto_coma 
{:
    for(int i = 0; i < r.size(); i++)
        r.get(i).getHijos().add(0, t);

    RESULT = r;
:};

DECLARACIONCON  ::= pr_const pr_entero:t id:i igual octa_e:v punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    hijos.add(v);
    Nodo n = new Nodo(accion.declaracionConsSim, accion.acciones[accion.declaracionConsSim], 1, 1, hijos, false);
    
    ArrayList<Nodo> dc = new ArrayList<Nodo> ();
    dc.add(n);
    RESULT = dc;
:};

DECLARACIONCON  ::= pr_const pr_entero:t id:i igual hexa_e:v punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    hijos.add(v);
    Nodo n = new Nodo(accion.declaracionConsSim, accion.acciones[accion.declaracionConsSim], 1, 1, hijos, false);
    
    ArrayList<Nodo> dc = new ArrayList<Nodo> ();
    dc.add(n);
    RESULT = dc;
:};

DECLARACIONCON  ::= pr_const pr_real:t id:i igual octa_r:v punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    hijos.add(v);
    Nodo n = new Nodo(accion.declaracionConsSim, accion.acciones[accion.declaracionConsSim], 1, 1, hijos, false);
    
    ArrayList<Nodo> dc = new ArrayList<Nodo> ();
    dc.add(n);
    RESULT = dc;
:};

DECLARACIONCON  ::= pr_const pr_real:t id:i igual hexa_r:v punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    hijos.add(v);
    Nodo n = new Nodo(accion.declaracionConsSim, accion.acciones[accion.declaracionConsSim], 1, 1, hijos, false);
    
    ArrayList<Nodo> dc = new ArrayList<Nodo> ();
    dc.add(n);
    RESULT = dc;
:};

DECLARACIONFUNCION  ::= DECLARACIONFUNCIONCABECERA:dc BLOQUE:b
{:
    dc.addAll(b);
    RESULT = new Nodo(accion.funcion, accion.acciones[accion.funcion], 1, 1, dc, false);
:};

DECENTERO ::= id:i igual octa_e:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECENTERO ::= id:i igual hexa_e:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECENTERO ::=  DECALL:da punto_coma
{:
    RESULT = da;
:};

DECREAL ::= id:i igual octa_r:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECREAL ::= id:i igual hexa_r:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECREAL ::= DECALL:da punto_coma
{:
    RESULT = da;
:};

DECALL  ::= DECSIMPLE:ds
{:
    ArrayList<Nodo> da = new ArrayList<Nodo>();
    da.add(ds);
    RESULT = da;
:};

DECALL  ::= DECVECT:dv
{:
    ArrayList<Nodo> da = new ArrayList<Nodo>();
    da.add(dv);
    RESULT = da;
:};

DECALL  ::= DECMAT:dm
{:
    ArrayList<Nodo> da = new ArrayList<Nodo>();
    da.add(dm);
    RESULT = da;
:};

DECALL  ::= DECSIMPLE:ds coma DECALL:da
{:
    da.add(0, ds);
    RESULT = da;
:};

DECALL  ::= DECVECT:dv coma DECALL:da
{:
    da.add(0, dv);
    RESULT = da;
:};

DECALL  ::= DECMAT:dm coma DECALL:da
{:
    da.add(0, dm);
    RESULT = da;
:};


DECSIMPLE  ::= id:i igual EXPGEN:v
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(v);
    RESULT = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
:};

DECSIMPLE  ::= id:i
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    RESULT = new Nodo(accion.declaracionSim, accion.acciones[accion.declaracionSim], 1, 1, hijos, false);
:};

DECVECT  ::= id:i INDICE:i1 igual EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(e);
    RESULT = new Nodo(accion.declaracionVecIni, accion.acciones[accion.declaracionVecIni], 1, 1, hijos, false);
:};

DECVECT  ::= id:i INDICE:i1 igual VECTOR:v 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(v);
    RESULT = new Nodo(accion.declaracionVecIni, accion.acciones[accion.declaracionVecIni], 1, 1, hijos, false);
:};

DECVECT  ::= id:i INDICE:i1
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    RESULT = new Nodo(accion.declaracionVec, accion.acciones[accion.declaracionVec], 1, 1, hijos, false);
:};

DECMAT  ::= id:i INDICE:i1 INDICE:i2 igual EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(i2);
    hijos.add(e);
    RESULT = new Nodo(accion.declaracionMatIni, accion.acciones[accion.declaracionMatIni], 1, 1, hijos, false);
:};

DECMAT  ::= id:i INDICE:i1 INDICE:i2 igual MATRIZ:m 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(i2);
    hijos.add(m);
    RESULT = new Nodo(accion.declaracionMatIni, accion.acciones[accion.declaracionMatIni], 1, 1, hijos, false);
:};

DECMAT  ::= id:i INDICE:i1 INDICE:i2
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(i2);
    RESULT = new Nodo(accion.declaracionMat, accion.acciones[accion.declaracionMat], 1, 1, hijos, false);
:};

DECCAD  ::= id:i igual cadena:v 
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(i);
    hijos.add(v);
    RESULT = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
:};

DECCAD  ::= id:i 
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(i);
    RESULT = new Nodo(accion.declaracionSim, accion.acciones[accion.declaracionSim], 1, 1, hijos, false);
:};

DECCADALL ::= DECCAD:c
{:
    ArrayList<Nodo> cadenas = new ArrayList <Nodo>();
    cadenas.add(c);
    RESULT = cadenas;
:};

DECCADALL ::= DECCAD:c coma DECCADALL:dca
{:
    dca.add(0, c);
    RESULT = dca;
:};


DECCONALL  ::= DECCON:c
{:
    ArrayList<Nodo> constantes = new ArrayList <Nodo>();
    constantes.add(c);
    RESULT = constantes;
:};

DECCONALL  ::= DECCON:c coma DECCONALL:dca
{:
    dca.add(0, c);
    RESULT = dca;
:};


DECCON	::= id:i igual EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(e);
    RESULT = new Nodo(accion.declaracionConsSim, accion.acciones[accion.declaracionConsSim], 1, 1, hijos, false);
:};

DECCON	::= id:i INDICE:i1 igual EXPGEN:e 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(e);
    RESULT = new Nodo(accion.declaracionConsVec, accion.acciones[accion.declaracionConsVec], 1, 1, hijos, false);
:};

DECCON	::= id:i INDICE:i1 igual VECTOR:v
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(v);
    RESULT = new Nodo(accion.declaracionConsVec, accion.acciones[accion.declaracionConsVec], 1, 1, hijos, false);
:};

DECCON	::= id:i INDICE:i1 INDICE:i2 igual EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(i2);
    hijos.add(e);
    RESULT = new Nodo(accion.declaracionConsMat, accion.acciones[accion.declaracionConsMat], 1, 1, hijos, false);
:};

DECCON	::= id:i INDICE:i1 INDICE:i2 igual MATRIZ:m
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(i1);
    hijos.add(i2);
    hijos.add(m);
    RESULT = new Nodo(accion.declaracionConsMat, accion.acciones[accion.declaracionConsMat], 1, 1, hijos, false);
:};

BLOQUE  ::= ll_ab NSENTENCIA:s ll_ce
{:
    Nodo declaracionVar = new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()),false);
    Nodo bloque = new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, s, false);
    ArrayList<Nodo> hijosProgPrin = new ArrayList<Nodo>();
    hijosProgPrin.add(declaracionVar);
    hijosProgPrin.add(bloque);
    RESULT = hijosProgPrin;
:};

BLOQUE  ::= ll_ab DEFINICIONVARIABLE:dv NSENTENCIA:s ll_ce 
{:
    Nodo declaracionVar = new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, dv,false);
    Nodo bloque = new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, s, false);
    ArrayList<Nodo> hijosProgPrin = new ArrayList<Nodo>();
    hijosProgPrin.add(declaracionVar);
    hijosProgPrin.add(bloque);
    RESULT = hijosProgPrin;
:};

BLOQUE  ::= ll_ab DEFINICIONVARIABLE:dv ll_ce 
{:
    Nodo declaracionVar = new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, dv,false);
    Nodo bloque = new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, (new ArrayList<Nodo>()), false);
    ArrayList<Nodo> hijosProgPrin = new ArrayList<Nodo>();
    hijosProgPrin.add(declaracionVar);
    hijosProgPrin.add(bloque);
    RESULT = hijosProgPrin;
:};

BLOQUE  ::= ll_ab ll_ce 
{:
    Nodo declaracionVar = new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()),false);
    Nodo bloque = new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, (new ArrayList<Nodo>()), false);
    ArrayList<Nodo> hijosProgPrin = new ArrayList<Nodo>();
    hijosProgPrin.add(declaracionVar);
    hijosProgPrin.add(bloque);
    RESULT = hijosProgPrin;
:};

NSENTENCIA  ::= SENTENCIA:s NSENTENCIA:sentencias 
{:
    sentencias.add(0, s);
    RESULT = sentencias;
:};

NSENTENCIA  ::= SENTENCIA:s   
{:
    ArrayList<Nodo> sentencias = new ArrayList<Nodo>();
    sentencias.add(s);
    RESULT = sentencias;
:};

SENTENCIA  ::= ASIGNACION:s
{:
    RESULT = s;
:};

SENTENCIA  ::= CONDICIONALHACERMIENTRAS:s
{:
    RESULT = s;
:};

SENTENCIA  ::= CONDICIONALMIENTRAS:s
{:
    RESULT = s;
:};

SENTENCIA  ::= CONDICIONALPARA:s
{:
    RESULT = s;
:};

SENTENCIA  ::= CONDICIONALSI:s
{:
    RESULT = s;
:};

SENTENCIA  ::= SENTSELECTOR:s
{:
    RESULT = s;
:};

SENTENCIA  ::= LLAMADAFUNCION:s punto_coma
{:
    RESULT = s;
:};

SENTENCIA  ::= ESCRITURA:s
{:
    RESULT = s;
:};

SENTENCIA  ::= LECTURA:s
{:
    RESULT = s;
:};

SENTENCIA  ::= ACT:s punto_coma
{:
    RESULT = s;
:};

SENTENCIA  ::= pr_retornar EXPGEN:e punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(e);
    RESULT = new Nodo(accion.retornar, accion.acciones[accion.retornar], 1, 1, hijos, false);
:};

SENTENCIA  ::= pr_retornar punto_coma
{:
    RESULT = new Nodo(accion.retornar, accion.acciones[accion.retornar], 1, 1, (new ArrayList<Nodo>()), false);
:};

SENTENCIA ::= pr_saltar punto_coma
{:
    RESULT = new Nodo(accion.saltar, accion.acciones[accion.saltar], 1, 1, (new ArrayList<Nodo>()), false);
:};

ACT  ::= id:i decr 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    
    ArrayList<Nodo> hijosRes = new ArrayList<Nodo>();
    hijosRes.add(i);
    Nodo uno = new Nodo(sym.numero, "1", 1, 1, null, true);
    hijosRes.add(uno);
    Nodo resta = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, hijosRes, false);
    
    hijos.add(resta);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ACT  ::= id:i incr 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    
    ArrayList<Nodo> hijosSum = new ArrayList<Nodo>();
    hijosSum.add(i);
    Nodo uno = new Nodo(sym.numero, "1", 1, 1, null, true);
    hijosSum.add(uno);
    Nodo suma = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, hijosSum, false);
    
    hijos.add(suma);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ACT  ::= id:i a_div EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    
    ArrayList<Nodo> hijosDiv = new ArrayList<Nodo>();
    hijosDiv.add(i);
    hijosDiv.add(e);
    Nodo div = new Nodo(accion.division, accion.acciones[accion.division], 1, 1, hijosDiv, false);
    
    hijos.add(div);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ACT  ::= id:i a_prod EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    
    ArrayList<Nodo> hijosProd = new ArrayList<Nodo>();
    hijosProd.add(i);
    hijosProd.add(e);
    Nodo prod = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, hijosProd, false);
    
    hijos.add(prod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ACT  ::= id:i a_resta EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    
    ArrayList<Nodo> hijosRes = new ArrayList<Nodo>();
    hijosRes.add(i);
    hijosRes.add(e);
    Nodo res = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, hijosRes, false);
    
    hijos.add(res);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ACT  ::= id:i a_suma EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    
    ArrayList<Nodo> hijosSum = new ArrayList<Nodo>();
    hijosSum.add(i);
    hijosSum.add(e);
    Nodo sum = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, hijosSum, false);
    
    hijos.add(sum);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ACT  ::= id:i igual EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(e);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ACT  ::= id:i a_mod EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    
    ArrayList<Nodo> hijosMod = new ArrayList<Nodo>();
    hijosMod.add(i);
    hijosMod.add(e);
    Nodo mod = new Nodo(accion.modulo, accion.acciones[accion.modulo], 1, 1, hijosMod, false);
    
    hijos.add(mod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};


EXPGEN ::= OPERANDO:o 
{:
    RESULT = o;
:};

EXPGEN ::= EXPRESION:e 
{:
    RESULT = e;
:};



EXPRESION  ::= EXPGEN:e1 dif EXPGEN:e2 
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.diferente, accion.acciones[accion.diferente], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 ident EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.identico, accion.acciones[accion.identico], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mas EXPGEN:e2  
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 menos EXPGEN:e2 
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 prod EXPGEN:e2 
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 div EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.division, accion.acciones[accion.division], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mayor EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.mayor, accion.acciones[accion.mayor], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mayor_igual EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.mayor_igual, accion.acciones[accion.mayor_igual], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 menor EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.menor, accion.acciones[accion.menor], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 menor_igual EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.menor_igual, accion.acciones[accion.menor_igual], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mod EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.modulo, accion.acciones[accion.modulo], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 o EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.disyuncion, accion.acciones[accion.disyuncion], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 y EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.conjuncion, accion.acciones[accion.conjuncion], 1, 1, operandos, false);
:};


EXPRESION  ::= EXPGEN:e1 inv
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.inversa, accion.acciones[accion.inversa], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 transp
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.transpuesta, accion.acciones[accion.transpuesta], 1, 1, operandos, false);
:};


EXPRESION  ::= neg OPERANDO:o1
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(o1);
    RESULT = new Nodo(accion.negacion, accion.acciones[accion.negacion], 1, 1, operandos, false);
:};

EXPRESION  ::= neg par_ab EXPRESION:e1 par_ce
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.negacion, accion.acciones[accion.negacion], 1, 1, operandos, false);
:};

EXPRESION  ::= mas OPERANDO:o1
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(o1);
    RESULT = new Nodo(accion.positividad, accion.acciones[accion.positividad], 1, 1, operandos, false);
:} %prec premas;

EXPRESION  ::= mas par_ab EXPRESION:e1 par_ce
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.positividad, accion.acciones[accion.positividad], 1, 1, operandos, false);
:} %prec premas;

EXPRESION  ::= menos OPERANDO:o1
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(o1);
    RESULT = new Nodo(accion.negatividad, accion.acciones[accion.negatividad], 1, 1, operandos, false);
:} %prec premenos;

EXPRESION  ::= menos par_ab EXPRESION:e1 par_ce
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.negatividad, accion.acciones[accion.negatividad], 1, 1, operandos, false);
:} %prec premenos;

EXPRESION  ::= OPERADORFUNCION:of
{:
    RESULT = of;
:};

EXPRESION  ::= OPERADORCOND:op
{: 
    RESULT = op;
:};

EXPRESION  ::= par_ab EXPRESION:e par_ce 
{:
    RESULT = e;
:};

EXPRESION  ::= par_ab OPERANDO:o par_ce 
{:
    RESULT = o;
:};

ARGUMENTO  ::= EXPGEN:e
{:
    ArrayList<Nodo> arg = new ArrayList<Nodo>();
    arg.add(e);
    RESULT = arg;
:};

ARGUMENTO  ::= EXPGEN:e coma ARGUMENTO:a
{:
    a.add(0, e);
    RESULT = a;
:};


ASIGNACION  ::= id:i igual cadena:v punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(v);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i a_div EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    ArrayList<Nodo> hijosDiv = new ArrayList<Nodo>();
    hijosDiv.add(i);
    hijosDiv.add(e);
    Nodo div = new Nodo(accion.division, accion.acciones[accion.division], 1, 1, hijosDiv, false );
    hijos.add(div);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i a_prod EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    ArrayList<Nodo> hijosProd = new ArrayList<Nodo>();
    hijosProd.add(i);
    hijosProd.add(e);
    Nodo prod = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, hijosProd, false );
    hijos.add(prod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i a_resta EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    ArrayList<Nodo> hijosRes = new ArrayList<Nodo>();
    hijosRes.add(i);
    hijosRes.add(e);
    Nodo res = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, hijosRes, false );
    hijos.add(res);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i a_suma EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    ArrayList<Nodo> hijosSum = new ArrayList<Nodo>();
    hijosSum.add(i);
    hijosSum.add(e);
    Nodo sum = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, hijosSum, false );
    hijos.add(sum);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i igual EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(e);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i a_mod EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    ArrayList<Nodo> hijosMod = new ArrayList<Nodo>();
    hijosMod.add(i);
    hijosMod.add(e);
    Nodo mod = new Nodo(accion.modulo, accion.acciones[accion.modulo], 1, 1, hijosMod, false );
    hijos.add(mod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};


ASIGNACION  ::= id:i INDICE:i1 a_div EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo aVec = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijosVec, false);
    
    hijos.add(aVec);
    
    ArrayList<Nodo> hijosDiv = new ArrayList<Nodo>();
    hijosDiv.add(aVec);
    hijosDiv.add(e);
    Nodo div = new Nodo(accion.division, accion.acciones[accion.division], 1, 1, hijosDiv, false );

    hijos.add(div);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 a_prod EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo aVec = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijosVec, false);
    
    hijos.add(aVec);
    
    ArrayList<Nodo> hijosProd = new ArrayList<Nodo>();
    hijosProd.add(aVec);
    hijosProd.add(e);
    Nodo prod = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, hijosProd, false );

    hijos.add(prod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 a_resta EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo aVec = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijosVec, false);
    
    hijos.add(aVec);
    
    ArrayList<Nodo> hijosRes = new ArrayList<Nodo>();
    hijosRes.add(aVec);
    hijosRes.add(e);
    Nodo res = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, hijosRes, false );

    hijos.add(res);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 a_suma EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo aVec = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijosVec, false);
    
    hijos.add(aVec);
    
    ArrayList<Nodo> hijosSum = new ArrayList<Nodo>();
    hijosSum.add(aVec);
    hijosSum.add(e);
    Nodo sum = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, hijosSum, false );

    hijos.add(sum);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 igual EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo aVec = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijosVec, false);
    
    hijos.add(aVec);
    hijos.add(e);

    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 a_mod EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo aVec = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijosVec, false);
    
    hijos.add(aVec);
    
    ArrayList<Nodo> hijosMod = new ArrayList<Nodo>();
    hijosMod.add(aVec);
    hijosMod.add(e);
    Nodo mod = new Nodo(accion.modulo, accion.acciones[accion.modulo], 1, 1, hijosMod, false );

    hijos.add(mod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 INDICE:i2 a_div EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo aMat = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijosMat, false);
    
    hijos.add(aMat);
    
    ArrayList<Nodo> hijosDiv = new ArrayList<Nodo>();
    hijosDiv.add(aMat);
    hijosDiv.add(e);
    Nodo div = new Nodo(accion.division, accion.acciones[accion.division], 1, 1, hijosDiv, false );

    hijos.add(div);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 INDICE:i2 a_prod EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo aMat = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijosMat, false);
    
    hijos.add(aMat);
    
    ArrayList<Nodo> hijosProd = new ArrayList<Nodo>();
    hijosProd.add(aMat);
    hijosProd.add(e);
    Nodo prod = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, hijosProd, false );

    hijos.add(prod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 INDICE:i2 a_resta EXPGEN:e punto_coma
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo aMat = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijosMat, false);
    
    hijos.add(aMat);
    
    ArrayList<Nodo> hijosRes = new ArrayList<Nodo>();
    hijosRes.add(aMat);
    hijosRes.add(e);
    Nodo res = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, hijosRes, false );

    hijos.add(res);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 INDICE:i2 a_suma EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo aMat = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijosMat, false);
    
    hijos.add(aMat);
    
    ArrayList<Nodo> hijosSum = new ArrayList<Nodo>();
    hijosSum.add(aMat);
    hijosSum.add(e);
    Nodo sum = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, hijosSum, false );

    hijos.add(sum);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 INDICE:i2 igual EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo aMat = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijosMat, false);
    
    hijos.add(aMat);
    hijos.add(e);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

ASIGNACION  ::= id:i INDICE:i1 INDICE:i2 a_mod EXPGEN:e punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();

    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo aMat = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijosMat, false);
    
    hijos.add(aMat);
    
    ArrayList<Nodo> hijosMod = new ArrayList<Nodo>();
    hijosMod.add(aMat);
    hijosMod.add(e);
    Nodo mod = new Nodo(accion.modulo, accion.acciones[accion.modulo], 1, 1, hijosMod, false );

    hijos.add(mod);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};




CONDICIONAL  ::= par_ab OPERANDO:op par_ce 
{:
    RESULT = op;
:};

CONDICIONAL  ::= par_ab EXPRESION:e par_ce 
{:
    RESULT = e;
:};


CONDICIONALHACERMIENTRAS  ::= pr_hacer BLOQUE:b pr_mientras CONDICIONAL:c punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    hijos.addAll(b);
    RESULT = new Nodo(accion.hacerMientras, accion.acciones[accion.hacerMientras], 1, 1, hijos, false);
:};

CONDICIONALHACERMIENTRAS  ::= pr_hacer SENTENCIA:s pr_mientras CONDICIONAL:c punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent = new ArrayList<Nodo>();
    sent.add(s);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent, false));
    RESULT = new Nodo(accion.hacerMientras, accion.acciones[accion.hacerMientras], 1, 1, hijos, false);
:};

CONDICIONALMIENTRAS  ::= pr_mientras CONDICIONAL:c BLOQUE:b 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    hijos.addAll(b);
    RESULT = new Nodo(accion.mientras, accion.acciones[accion.mientras], 1, 1, hijos, false);
:};

CONDICIONALMIENTRAS  ::= pr_mientras CONDICIONAL:c SENTENCIA:s
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent = new ArrayList<Nodo>();
    sent.add(s);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent, false));
    RESULT = new Nodo(accion.mientras, accion.acciones[accion.mientras], 1, 1, hijos, false);
:};

CONDICIONALPARA  ::= pr_para CONTROLADOR:c BLOQUE:b
{:
    c.addAll(b);
    RESULT = new Nodo(accion.para, accion.acciones[accion.para], 1, 1, c, false);
:};

CONDICIONALPARA  ::= pr_para CONTROLADOR:c SENTENCIA:s
{: 
    c.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent = new ArrayList<Nodo>();
    sent.add(s);
    c.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent, false));
    RESULT = new Nodo(accion.para, accion.acciones[accion.para], 1, 1, c, false);
:};

CONDICIONALSI  ::= pr_si CONDICIONAL:c BLOQUE:b
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    hijos.addAll(b);
    
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, (new ArrayList<Nodo>()), false));
    RESULT = new Nodo(accion.si, accion.acciones[accion.si], 1, 1, hijos, false);
:};

CONDICIONALSI  ::= pr_si CONDICIONAL:c BLOQUE:b1 pr_sino BLOQUE:b2
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    hijos.addAll(b1);
    hijos.addAll(b2);
    
    RESULT = new Nodo(accion.si, accion.acciones[accion.si], 1, 1, hijos, false);
:};

CONDICIONALSI  ::= pr_si CONDICIONAL:c SENTENCIA:s
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent = new ArrayList<Nodo>();
    sent.add(s);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent, false));
    
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, (new ArrayList<Nodo>()), false));
    RESULT = new Nodo(accion.si, accion.acciones[accion.si], 1, 1, hijos, false);
:};

CONDICIONALSI  ::= pr_si CONDICIONAL:c BLOQUE:b pr_sino SENTENCIA:s
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    hijos.addAll(b);
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent = new ArrayList<Nodo>();
    sent.add(s);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent, false));
    
    RESULT = new Nodo(accion.si, accion.acciones[accion.si], 1, 1, hijos, false);
:};

CONDICIONALSI  ::= pr_si CONDICIONAL:c SENTENCIA:s pr_sino BLOQUE:b
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent = new ArrayList<Nodo>();
    sent.add(s);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent, false));
    hijos.addAll(b);

    RESULT = new Nodo(accion.si, accion.acciones[accion.si], 1, 1, hijos, false);
:};

CONDICIONALSI  ::= pr_si CONDICIONAL:c SENTENCIA:s1 pr_sino SENTENCIA:s2
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);

    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent1 = new ArrayList<Nodo>();
    sent1.add(s1);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent1, false));
    
    hijos.add(new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()), false));
    ArrayList<Nodo> sent2 = new ArrayList<Nodo>();
    sent2.add(s2);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, sent2, false));

    RESULT = new Nodo(accion.si, accion.acciones[accion.si], 1, 1, hijos, false);
:};


CONTROLADOR  ::= par_ab INI:ini punto_coma EXPGEN:e punto_coma ACT:a par_ce 
{:
    ArrayList<Nodo> ctrl = new ArrayList<Nodo>();
    ctrl.add(ini);
    ctrl.add(e);
    ctrl.add(a);
    RESULT = ctrl;
:};


ESCRITURA  ::= pr_mostrar par_ab EXPGEN:e par_ce punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(e);
    RESULT = new Nodo(accion.escritura, accion.acciones[accion.escritura],1 ,1, hijos, false);
:};

ESCRITURA  ::= pr_mostrar par_ab cadena:c par_ce punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(c);
    RESULT = new Nodo(accion.escritura, accion.acciones[accion.escritura],1 ,1, hijos, false);
:};

ESCRITURA  ::= pr_mostrar par_ab par_ce punto_coma 
{:
    RESULT = new Nodo(accion.escritura, accion.acciones[accion.escritura],1 ,1, (new ArrayList<Nodo>()), false);
:};

INDICE  ::= cor_ab EXPGEN:e cor_ce 
{:
    RESULT = e;
:};


INI  ::= id:i igual EXPGEN:e
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(e);
    RESULT = new Nodo(accion.asignacion, accion.acciones[accion.asignacion], 1, 1, hijos, false);
:};

INI  ::= pr_entero:t id:i igual EXPGEN:e 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(t);
    hijos.add(i);
    hijos.add(e);
    RESULT = new Nodo(accion.declaracionSim, accion.acciones[accion.declaracionSim], 1, 1, hijos, false);
:};

LECTURA  ::= pr_leer par_ab id:i par_ce punto_coma 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    RESULT = new Nodo(accion.lectura, accion.acciones[accion.lectura], 1, 1, hijos, false);
:};



MATRIZ  ::= ll_ab NVECTOR:nvec ll_ce 
{:
    RESULT = new Nodo(accion.elemMat, accion.acciones[accion.elemMat], 1, 1, nvec, false);
:};

NVECTOR  ::= VECTOR:v
{:
    ArrayList <Nodo> vectores = new ArrayList<Nodo>();
    vectores.add(v);
    RESULT = vectores;
:};

NVECTOR  ::= VECTOR:v coma NVECTOR:nvec
{:
    nvec.add(0, v);
    RESULT = nvec;
:};

VECTOR  ::= ll_ab NELEMENTO:el ll_ce 
{:
    RESULT = new Nodo(accion.elemVec, accion.acciones[accion.elemVec], 1, 1, el, false);
:};

NELEMENTO  ::= EXPGEN:e
{:
    ArrayList<Nodo> elementos = new ArrayList<Nodo>();
    elementos.add(e);
    RESULT = elementos;
:};

NELEMENTO  ::= EXPGEN:e coma NELEMENTO:elem 
{:
    elem.add(0, e);
    RESULT = elem;
:};


DECLARACIONFUNCIONCABECERA  ::= TIPOVARIABLEFUNCION:t id:i par_ab PARAMETRO:param par_ce
{:
    ArrayList<Nodo> dfc = new ArrayList<Nodo>();
    dfc.add(t);
    dfc.add(i);
    dfc.add(new Nodo(accion.parametroFun, accion.acciones[accion.parametroFun], 1, 1, param, false));
    RESULT = dfc;
:};

DECLARACIONFUNCIONCABECERA  ::= TIPOVARIABLEFUNCION:t id:i par_ab par_ce
{:
    ArrayList<Nodo> dfc = new ArrayList<Nodo>();
    dfc.add(t);
    dfc.add(i);
    dfc.add(new Nodo(accion.parametroFun, accion.acciones[accion.parametroFun], 1, 1, (new ArrayList<Nodo>()), false));
    RESULT = dfc;
:};


TIPOVARIABLEFUNCION  ::= TIPONUMERO:t
{:
    RESULT = t;
:};

TIPOVARIABLEFUNCION  ::= pr_vacio:v
{:
    RESULT = v;
:};

DEFINICIONVARIABLE  ::= DECLARACION:d DEFINICIONVARIABLE:r
{:
    d.addAll(r);
    RESULT = d;
:};

DEFINICIONVARIABLE  ::= DECLARACION:d
{:
    RESULT = d;
:};


PARAMETRO  ::= TIPONUMERO:t id:i coma PARAMETRO:param
{:
    ArrayList<Nodo> hijosSim = new ArrayList<Nodo>();
    hijosSim.add(t);
    hijosSim.add(i);
    Nodo sim = new Nodo(accion.parametroFunSim, accion.acciones[accion.parametroFunSim], 1, 1, hijosSim, false);
    param.add(0, sim);
    RESULT = param;
:};

PARAMETRO  ::= TIPONUMERO:t id:i INDICE:i1 coma PARAMETRO:param
{:
    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(t);
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo vec = new Nodo(accion.parametroFunVec, accion.acciones[accion.parametroFunVec], 1, 1, hijosVec, false);
    param.add(0, vec);
    RESULT = param;
:};

PARAMETRO  ::= TIPONUMERO:t id:i INDICE:i1 INDICE:i2 coma PARAMETRO:param
{:
    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(t);
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo mat = new Nodo(accion.parametroFunMat, accion.acciones[accion.parametroFunMat], 1, 1, hijosMat, false);
    param.add(0, mat);
    RESULT = param;
:};

PARAMETRO  ::= TIPONUMERO:t id:i INDICE:i1 INDICE:i2
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    ArrayList<Nodo> hijosMat = new ArrayList<Nodo>();
    hijosMat.add(t);
    hijosMat.add(i);
    hijosMat.add(i1);
    hijosMat.add(i2);
    Nodo mat = new Nodo(accion.parametroFunMat, accion.acciones[accion.parametroFunMat], 1, 1, hijosMat, false);
    param.add(mat);
    RESULT = param;
:};

PARAMETRO  ::= TIPONUMERO:t id:i INDICE:i1 
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    ArrayList<Nodo> hijosVec = new ArrayList<Nodo>();
    hijosVec.add(t);
    hijosVec.add(i);
    hijosVec.add(i1);
    Nodo vec = new Nodo(accion.parametroFunVec, accion.acciones[accion.parametroFunVec], 1, 1, hijosVec, false);
    param.add(vec);
    RESULT = param;
:};

PARAMETRO  ::= TIPONUMERO:t id:i
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    ArrayList<Nodo> hijosSim = new ArrayList<Nodo>();
    hijosSim.add(t);
    hijosSim.add(i);
    Nodo sim = new Nodo(accion.parametroFunSim, accion.acciones[accion.parametroFunSim], 1, 1, hijosSim, false);
    param.add(sim);
    RESULT = param;
:};

PARAMETROBINARIO  ::= par_ab EXPGEN:e1 coma EXPGEN:e2 par_ce
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    param.add(e1);
    param.add(e2);
    RESULT = param;
:};

PARAMETROUNARIO  ::= par_ab EXPGEN:e1 par_ce  
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    param.add(e1);
    RESULT = param;
:};

SENTSELECTOR  ::= pr_selector CONDICIONAL:c ll_ab NCASO:nc SENTDEFECTO:df ll_ce 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo> ();
    hijos.add(c);
    Nodo casos = new Nodo(accion.casos, accion.acciones[accion.casos], 1, 1, nc, false);
    hijos.add(casos);
    hijos.add(df);
    RESULT = new Nodo(accion.selector, accion.acciones[accion.selector], 1, 1, hijos, false);
:};

SENTSELECTOR  ::= pr_selector CONDICIONAL:c ll_ab NCASO:nc ll_ce 
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo> ();
    hijos.add(c);
    Nodo casos = new Nodo(accion.casos, accion.acciones[accion.casos], 1, 1, nc, false);
    hijos.add(casos);    
    hijos.add(new Nodo(accion.pordefecto, accion.acciones[accion.pordefecto], 1, 1, (new ArrayList<Nodo>()), false));
    RESULT = new Nodo(accion.selector, accion.acciones[accion.selector], 1, 1, hijos, false);
:};

NCASO  ::= SENTCASO:sc NCASO:casos
{:
    casos.add(0, sc);
    RESULT = casos;
:};

NCASO  ::= SENTCASO:sc
{:
    ArrayList<Nodo> casos = new ArrayList<Nodo>();
    casos.add(sc);
    RESULT = casos;
:};

SENTCASO  ::= pr_caso numero:n sig_pun NSENTENCIA:ns
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(n);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, ns, false));
    RESULT = new Nodo(accion.caso, accion.acciones[accion.caso], 1, 1, hijos, false);
:};

SENTCASO  ::= pr_caso numero:n sig_pun
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(n);
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, (new ArrayList<Nodo>()), false));
    RESULT = new Nodo(accion.caso, accion.acciones[accion.caso], 1, 1, hijos, false);
:};


SENTDEFECTO  ::= pr_default sig_pun NSENTENCIA:ns  
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, ns, false));
    RESULT = new Nodo(accion.pordefecto, accion.acciones[accion.pordefecto], 1, 1, hijos, false);
:};

SENTDEFECTO  ::= pr_default sig_pun
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, (new ArrayList<Nodo>()), false));
    RESULT = new Nodo(accion.pordefecto, accion.acciones[accion.pordefecto], 1, 1, hijos, false);
:};


LLAMADAFUNCION  ::= id:i par_ab par_ce 
{:
    Nodo argumento = new Nodo(accion.argumento, accion.acciones[accion.argumento], 1, 1, (new ArrayList<Nodo>()), false);
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(argumento);
    RESULT = new Nodo(accion.llamadaFuncion, accion.acciones[accion.llamadaFuncion], 1, 1, hijos, false);
:};

LLAMADAFUNCION  ::= id:i par_ab ARGUMENTO:a par_ce 
{:
    Nodo argumento = new Nodo(accion.argumento, accion.acciones[accion.argumento], 1, 1, a, false);
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(argumento);
    RESULT = new Nodo(accion.llamadaFuncion, accion.acciones[accion.llamadaFuncion], 1, 1, hijos, false);
:};

OPERADORFUNCION  ::= pr_suma:op PARAMETROBINARIO:p
{:
    RESULT = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_resta:op PARAMETROBINARIO:p
{:
    RESULT = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_prod:op PARAMETROBINARIO:p
{:
    RESULT = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_transp:op PARAMETROUNARIO:p
{:
    RESULT = new Nodo(accion.transpuesta, accion.acciones[accion.transpuesta], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_inv:op PARAMETROUNARIO:p
{:
    RESULT = new Nodo(accion.inversa, accion.acciones[accion.inversa], 1, 1, p,false);
:};

OPERADORCOND  ::= CONDICIONAL:e1 sig_int par_ab EXPGEN:e2 par_ce sig_pun par_ab EXPGEN:e3 par_ce
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    operandos.add(e3);
    RESULT = new Nodo(accion.operacionCond, accion.acciones[accion.operacionCond], 1, 1, operandos, false);
:};

OPERANDOENTERO  ::= LLAMADAFUNCION:ll
{:
    RESULT = ll;
:};

OPERANDOENTERO  ::= id:i INDICE:d1 INDICE:d2
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(d1);
    hijos.add(d2);
    RESULT = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijos, false);
:};

OPERANDOENTERO  ::= id:i INDICE:d1
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(d1);
    RESULT = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijos, false);
:};

OPERANDOENTERO  ::= id:i
{:
    RESULT = i;
:};

OPERANDOENTERO  ::= numero:n
{:
    RESULT = n;
:};

OPERANDO  ::= OPERANDOENTERO:oe
{:
    RESULT = oe;
:};

OPERANDO  ::= real:r
{:
    RESULT = r;
:};

OPERANDO  ::= octa_e:o
{:
    RESULT = o;
:};

OPERANDO  ::= octa_r:o
{:
    RESULT = o;
:};

OPERANDO  ::= hexa_e:h
{:
    RESULT = h;
:};

OPERANDO  ::= hexa_r:h
{:
    RESULT = h;
:};

TIPONUMERO  ::= pr_entero:e
{:
    RESULT = e;
:};

TIPONUMERO  ::= pr_real:r
{:
    RESULT = r;
:};