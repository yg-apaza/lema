package lema;

import java.util.ArrayList;

parser code
{:
    public Nodo raiz;
    
    Nodo entero = new Nodo(sym.pr_entero, "entero", 1, 1, null, true);
    Nodo real = new Nodo(sym.pr_real, "real", 1, 1, null, true);

    public void report_error(String message, Object info)
    {   
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol)
        {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0)
            {                
                m.append(" en la lÃ­nea " + (s.left + 1));   

                if (s.right >= 0)                    
                    m.append(", columna " + (s.right + 1));
            }
        }

        m.append(" : " + message);

        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info)
    {
        report_error(message, info);
        System.exit(1);
    }

    public Nodo getAST()
    {
        return raiz;
    }
:};


/* DECLARACION DE TERMINALES */

terminal Nodo pr_const, pr_vacio, pr_entero, pr_real, pr_cadena, 
par_ab, par_ce, cor_ab, cor_ce, ll_ab, ll_ce, 
mas, menos, prod, div, mod, transp, inv, incr, decr, 
ident, dif, menor, mayor, menor_igual, mayor_igual, y, o, neg, igual, 
pr_suma, pr_resta, pr_prod, pr_transp, pr_inv, 
a_suma, a_resta, a_prod, a_div, a_mod, 
sig_int, sig_pun, 
octa_e, octa_r, hexa_e, hexa_r, numero, real, cadena, 
pr_leer, pr_mostrar, 
pr_principal,
pr_si, pr_sino, pr_mientras, pr_hacer, pr_para, pr_selector, pr_saltar, pr_caso, pr_default, pr_retornar,
punto_coma, coma,
id, premas, premenos,
err;




/* DECLARACION DE NO TERMINALES */

non terminal Nodo PROGRAMA, 
PROGRAMAPRINCIPAL,

EXPRESION, EXPGEN,
SENTENCIA, NSENTENCIA,

DECLARACIONFUNCION, DECLARACIONFUNCIONCABECERA, 
DEFINICIONFUNCION,
DECSIMPLE, DECVECT, DECMAT, 

DECCON, DECCONALL,
DECCAD, DECCADALL,
DEFINICIONPROTOTIPO,

PARAMETRO, PARAMETROPROTOTIPO,

ASIGNACION, LLAMADAFUNCION, 
CONDICIONALHACERMIENTRAS, CONDICIONALMIENTRAS, CONDICIONALPARA, CONDICIONALSI, 
SENTSELECTOR, SENTDEFECTO,
NCASO, SENTCASO, 

ESCRITURA, LECTURA, 
MATRIZ, NELEMENTO, NVECTOR, VECTOR,
INDICE, INI, ACT,
CONDICIONAL, CONTROLADOR, 

OPERANDOENTERO, OPERADORASIGNACION, OPERADORPALABRAUNARIO, OPERADORPALABRABINARIO,
OPERADORFUNCION, OPERADORCOND, 
OPERANDO,
TIPONUMERO, TIPOVARIABLEFUNCION;

non terminal ArrayList<Nodo> BLOQUE, DEFINICIONVARIABLE, DEFINICIONVARIABLECAB, DECLARACION,  DECLARACIONCON, DECENTERO, DECREAL, DECALL, ARGUMENTO,
PARAMETROBINARIO, PARAMETROUNARIO;

/* PRECEDENCIA */

precedence left y, o;
precedence left ident, dif, menor, mayor, menor_igual, mayor_igual;
precedence left mas, menos;
precedence left mod;
precedence left prod, div;
precedence left transp, inv;
precedence right incr, decr, neg;
precedence right premas, premenos;

precedence nonassoc pr_const; 
precedence nonassoc pr_vacio; 
precedence nonassoc pr_entero; 
precedence nonassoc pr_real; 
precedence nonassoc pr_cadena; 
 
precedence nonassoc par_ab; 
precedence nonassoc par_ce; 
precedence nonassoc cor_ab; 
precedence nonassoc cor_ce;
precedence nonassoc ll_ab; 
precedence nonassoc ll_ce; 
 
precedence nonassoc pr_suma; 
precedence nonassoc pr_resta; 
precedence nonassoc pr_prod; 
precedence nonassoc pr_transp; 
precedence nonassoc pr_inv; 
 
precedence nonassoc igual; 
precedence nonassoc a_suma; 
precedence nonassoc a_resta; 
precedence nonassoc a_prod; 
precedence nonassoc a_div; 
precedence nonassoc a_mod; 
precedence nonassoc sig_int; 
precedence nonassoc sig_pun; 
 
precedence nonassoc octa_e; 
precedence nonassoc octa_r; 
precedence nonassoc hexa_e; 
precedence nonassoc hexa_r; 
precedence nonassoc numero; 
precedence nonassoc real; 
precedence nonassoc cadena; 

precedence nonassoc pr_leer; 
precedence nonassoc pr_mostrar; 
precedence nonassoc punto_coma; 
precedence nonassoc coma; 
precedence nonassoc pr_retornar; 
precedence nonassoc pr_si; 
precedence nonassoc pr_sino; 
precedence nonassoc pr_mientras; 
precedence nonassoc pr_hacer; 
precedence nonassoc pr_para; 
precedence nonassoc pr_selector; 
precedence nonassoc pr_saltar; 
precedence nonassoc pr_caso; 
precedence nonassoc pr_default; 
precedence nonassoc pr_principal; 
precedence nonassoc id; 
 
start with PROGRAMA;


PROGRAMA  ::= DEFINICIONVARIABLECAB:dvc PROGRAMAPRINCIPAL:pp
{:
    Nodo cab = new Nodo(accion.cabecera, accion.acciones[accion.cabecera], 1, 1, dvc, false);
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(cab);
    hijos.add(pp);
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMA  ::= DEFINICIONVARIABLECAB:dvc PROGRAMAPRINCIPAL:pp DEFINICIONFUNCION:df
{:
    Nodo cab = new Nodo(accion.cabecera, accion.acciones[accion.cabecera], 1, 1, dvc, false);
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(cab);
    hijos.add(pp);
    hijos.add(df);
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMA  ::= PROGRAMAPRINCIPAL:pp DEFINICIONFUNCION:df
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(pp);
    hijos.add(df);
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMA ::= PROGRAMAPRINCIPAL:pp
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    hijos.add(pp);
    RESULT = new Nodo(accion.programa, accion.acciones[accion.programa], 1, 1, hijos, false);
    raiz = RESULT;
:};

PROGRAMAPRINCIPAL  ::= pr_principal par_ab par_ce BLOQUE:b
{:
    ArrayList<Nodo> hijos = new ArrayList <Nodo>();
    RESULT = new Nodo(accion.programaPrincipal, accion.acciones[accion.programaPrincipal], 1, 1, b, false);
:};

DEFINICIONVARIABLECAB  ::= DECLARACION:d
{:
    RESULT = d;
:};

DEFINICIONVARIABLECAB  ::= DECLARACIONCON:c
{:
    RESULT = c;
:};

DEFINICIONVARIABLECAB  ::= DEFINICIONPROTOTIPO
;

DEFINICIONVARIABLECAB  ::= DECLARACION:d DEFINICIONVARIABLECAB:r
{:
    d.addAll(r);
    RESULT = d;
:};

DEFINICIONVARIABLECAB  ::= DECLARACIONCON:c DEFINICIONVARIABLECAB:r
{:
    c.addAll(r);
    RESULT = c;
:};

DEFINICIONVARIABLECAB  ::= DEFINICIONPROTOTIPO DEFINICIONVARIABLECAB
;

DEFINICIONPROTOTIPO	::= pr_entero id par_ab PARAMETROPROTOTIPO par_ce punto_coma
;
DEFINICIONPROTOTIPO	::= pr_entero id par_ab par_ce punto_coma
;
DEFINICIONPROTOTIPO	::= pr_real id par_ab PARAMETROPROTOTIPO par_ce punto_coma
;
DEFINICIONPROTOTIPO	::= pr_real id par_ab par_ce punto_coma
;
DEFINICIONPROTOTIPO	::= pr_vacio id par_ab PARAMETROPROTOTIPO par_ce punto_coma
;
DEFINICIONPROTOTIPO	::= pr_vacio id par_ab par_ce punto_coma
;

PARAMETROPROTOTIPO  ::= TIPONUMERO coma PARAMETROPROTOTIPO 
;
PARAMETROPROTOTIPO  ::= TIPONUMERO INDICE INDICE coma PARAMETROPROTOTIPO 
;
PARAMETROPROTOTIPO  ::= TIPONUMERO INDICE coma PARAMETROPROTOTIPO 
;
PARAMETROPROTOTIPO  ::= TIPONUMERO INDICE INDICE 
;
PARAMETROPROTOTIPO  ::= TIPONUMERO INDICE 
;
PARAMETROPROTOTIPO  ::= TIPONUMERO 
;


DEFINICIONFUNCION  ::= DECLARACIONFUNCION DEFINICIONFUNCION  
;
DEFINICIONFUNCION  ::= DECLARACIONFUNCION 
;



DECLARACION  ::= pr_entero DECENTERO:e
{:
    RESULT = e;
:};

DECLARACION  ::= pr_real DECREAL:r
{:
    RESULT = r;
:};

DECLARACION  ::= pr_cadena DECCADALL punto_coma
;




DECLARACIONCON  ::= pr_const pr_entero DECCONALL punto_coma 
;
DECLARACIONCON  ::= pr_const pr_real DECCONALL punto_coma 
;
DECLARACIONCON  ::= pr_const pr_entero id igual octa_e punto_coma 
;
DECLARACIONCON  ::= pr_const pr_entero id igual hexa_e punto_coma 
;
DECLARACIONCON  ::= pr_const pr_real id igual octa_r punto_coma 
;
DECLARACIONCON  ::= pr_const pr_real id igual hexa_r punto_coma 
;

DECLARACIONFUNCION  ::= DECLARACIONFUNCIONCABECERA BLOQUE 
;

DECENTERO ::= id:i igual octa_e:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(entero);
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECENTERO ::= id:i igual hexa_e:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(entero);
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECENTERO ::=  DECALL:da punto_coma
{:
    for(int i = 0; i < da.size(); i++)
        da.get(i).getHijos().add(0, entero);

    RESULT = da;
:};

DECREAL ::= id:i igual octa_r:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(real);
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECREAL ::= id:i igual hexa_r:v punto_coma
{:
    /* Declaracion con Inicializacion de un entero octal */
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(real);
    hijos.add(i);
    hijos.add(v);
    Nodo padre = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
    
    ArrayList<Nodo> dec = new ArrayList<Nodo>();
    dec.add(padre);

    RESULT = dec;
:};

DECREAL ::= DECALL:da punto_coma
{:
    for(int i = 0; i < da.size(); i++)
        da.get(i).getHijos().add(0, real);

    RESULT = da;
:};

DECALL  ::= DECSIMPLE:ds
{:
    ArrayList<Nodo> da = new ArrayList<Nodo>();
    da.add(ds);
    RESULT = da;
:};

DECALL  ::= DECVECT:dv
{:
    ArrayList<Nodo> da = new ArrayList<Nodo>();
    da.add(dv);
    RESULT = da;
:};

DECALL  ::= DECMAT:dm
{:
    ArrayList<Nodo> da = new ArrayList<Nodo>();
    da.add(dm);
    RESULT = da;
:};

DECALL  ::= DECSIMPLE:ds coma DECALL:da
{:
    da.add(0, ds);
    RESULT = da;
:};

DECALL  ::= DECVECT:dv coma DECALL:da
{:
    da.add(0, dv);
    RESULT = da;
:};

DECALL  ::= DECMAT:dm coma DECALL:da
{:
    da.add(0, dm);
    RESULT = da;
:};


DECSIMPLE  ::= id:i igual EXPGEN:v
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(v);
    RESULT = new Nodo(accion.declaracionSimIni, accion.acciones[accion.declaracionSimIni], 1, 1, hijos, false);
:};

DECSIMPLE  ::= id:i
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    RESULT = new Nodo(accion.declaracionSim, accion.acciones[accion.declaracionSim], 1, 1, hijos, false);
:};

DECVECT  ::= id INDICE igual EXPGEN 
;
DECVECT  ::= id INDICE igual VECTOR 
;
DECVECT  ::= id INDICE 
;

DECMAT  ::= id INDICE INDICE igual EXPGEN 
;
DECMAT  ::= id INDICE INDICE igual MATRIZ 
;
DECMAT  ::= id INDICE INDICE 
;


DECCAD  ::= id igual cadena 
;
DECCAD  ::= id 
;

DECCADALL	::= DECCAD
;
DECCADALL	::= DECCAD coma DECCADALL
;



DECCONALL  ::= DECCON 
;
DECCONALL  ::= DECCON coma DECCONALL 
;


DECCON	::= id igual EXPGEN 
;
DECCON	::= id INDICE igual EXPGEN 
;
DECCON	::= id INDICE igual VECTOR 
;
DECCON	::= id INDICE INDICE igual EXPGEN  
;
DECCON	::= id INDICE INDICE igual MATRIZ  
;


BLOQUE  ::= ll_ab NSENTENCIA ll_ce
{:
    /* NO SE  AGREGA AL ARBOL SEMANTICO */
:};

BLOQUE  ::= ll_ab DEFINICIONVARIABLE NSENTENCIA ll_ce 
{:
    /* NO SE  AGREGA AL ARBOL SEMANTICO */
:};

BLOQUE  ::= ll_ab DEFINICIONVARIABLE:dv ll_ce 
{:
    RESULT = dv;
:};

BLOQUE  ::= ll_ab ll_ce 
{:
    Nodo declaracionVar = new Nodo(accion.declaracionVar, accion.acciones[accion.declaracionVar], 1, 1, (new ArrayList<Nodo>()),false);
    Nodo bloque = new Nodo(accion.bloque, accion.acciones[accion.bloque], 1, 1, (new ArrayList<Nodo>()), false);
    ArrayList<Nodo> hijosProgPrin = new ArrayList<Nodo>();
    hijosProgPrin.add(declaracionVar);
    hijosProgPrin.add(bloque);
    RESULT = hijosProgPrin;
:};

NSENTENCIA  ::= SENTENCIA NSENTENCIA   
;
NSENTENCIA  ::= SENTENCIA   
;

SENTENCIA  ::= ASIGNACION
;
SENTENCIA  ::= CONDICIONALHACERMIENTRAS
;
SENTENCIA  ::= CONDICIONALMIENTRAS
;
SENTENCIA  ::= CONDICIONALPARA
;
SENTENCIA  ::= CONDICIONALSI
;
SENTENCIA  ::= SENTSELECTOR
;
SENTENCIA  ::= LLAMADAFUNCION punto_coma
;
SENTENCIA  ::= ESCRITURA
;
SENTENCIA  ::= LECTURA
;
SENTENCIA  ::= ACT punto_coma
;
SENTENCIA  ::= pr_retornar EXPGEN punto_coma
;
SENTENCIA  ::= pr_retornar punto_coma
;



ACT  ::= id decr 
;
ACT  ::= id incr 
;
ACT  ::= id OPERADORASIGNACION EXPGEN
;


EXPGEN ::= OPERANDO:o 
{:
    RESULT = o;
:};

EXPGEN ::= EXPRESION:e 
{:
    RESULT = e;
:};



EXPRESION  ::= EXPGEN:e1 dif EXPGEN:e2 
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.diferente, accion.acciones[accion.diferente], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 ident EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.identico, accion.acciones[accion.identico], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mas EXPGEN:e2  
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 menos EXPGEN:e2 
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 prod EXPGEN:e2 
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 div EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.division, accion.acciones[accion.division], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mayor EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.mayor, accion.acciones[accion.mayor], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mayor_igual EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.mayor_igual, accion.acciones[accion.mayor_igual], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 menor EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.menor, accion.acciones[accion.menor], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 menor_igual EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.menor_igual, accion.acciones[accion.menor_igual], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 mod EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.modulo, accion.acciones[accion.modulo], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 o EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.disyuncion, accion.acciones[accion.disyuncion], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 y EXPGEN:e2
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    operandos.add(e2);
    RESULT = new Nodo(accion.conjuncion, accion.acciones[accion.conjuncion], 1, 1, operandos, false);
:};


EXPRESION  ::= EXPGEN:e1 inv
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.inversa, accion.acciones[accion.inversa], 1, 1, operandos, false);
:};

EXPRESION  ::= EXPGEN:e1 transp
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.transpuesta, accion.acciones[accion.transpuesta], 1, 1, operandos, false);
:};


EXPRESION  ::= neg OPERANDO:o1
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(o1);
    RESULT = new Nodo(accion.negacion, accion.acciones[accion.negacion], 1, 1, operandos, false);
:};

EXPRESION  ::= neg par_ab EXPRESION:e1 par_ce
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.negacion, accion.acciones[accion.negacion], 1, 1, operandos, false);
:};

EXPRESION  ::= mas OPERANDO:o1
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(o1);
    RESULT = new Nodo(accion.positividad, accion.acciones[accion.positividad], 1, 1, operandos, false);
:} %prec premas;

EXPRESION  ::= mas par_ab EXPRESION:e1 par_ce
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.positividad, accion.acciones[accion.positividad], 1, 1, operandos, false);
:} %prec premas;

EXPRESION  ::= menos OPERANDO:o1
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(o1);
    RESULT = new Nodo(accion.negatividad, accion.acciones[accion.negatividad], 1, 1, operandos, false);
:} %prec premenos;

EXPRESION  ::= menos par_ab EXPRESION:e1 par_ce
{:
    ArrayList<Nodo> operandos = new ArrayList<Nodo>();
    operandos.add(e1);
    RESULT = new Nodo(accion.negatividad, accion.acciones[accion.negatividad], 1, 1, operandos, false);
:} %prec premenos;

EXPRESION  ::= OPERADORFUNCION:of
{:
    RESULT = of;
:};

EXPRESION  ::= OPERADORCOND
;


EXPRESION  ::= par_ab EXPRESION:e par_ce 
{:
    RESULT = e;
:};

EXPRESION  ::= par_ab OPERANDO:o par_ce 
{:
    RESULT = o;
:};







ARGUMENTO  ::= EXPGEN:e
{:
    ArrayList<Nodo> arg = new ArrayList<Nodo>();
    arg.add(e);
    RESULT = arg;
:};

ARGUMENTO  ::= EXPGEN:e coma ARGUMENTO:a
{:
    a.add(0, e);
    RESULT = a;
:};


ASIGNACION  ::= id igual cadena punto_coma 
;

ASIGNACION  ::= id OPERADORASIGNACION EXPGEN punto_coma 
;

ASIGNACION  ::= id INDICE OPERADORASIGNACION EXPGEN punto_coma 
;

ASIGNACION  ::= id INDICE INDICE OPERADORASIGNACION EXPGEN punto_coma 
;




CONDICIONAL  ::= par_ab OPERANDO par_ce 
;
CONDICIONAL  ::= par_ab EXPRESION par_ce 
;


CONDICIONALHACERMIENTRAS  ::= pr_hacer BLOQUE pr_mientras CONDICIONAL punto_coma 
;
CONDICIONALHACERMIENTRAS  ::= pr_hacer SENTENCIA pr_mientras CONDICIONAL punto_coma 
;

CONDICIONALMIENTRAS  ::= pr_mientras CONDICIONAL BLOQUE 
;
CONDICIONALMIENTRAS  ::= pr_mientras CONDICIONAL SENTENCIA 
;


CONDICIONALPARA  ::= pr_para CONTROLADOR BLOQUE 
;
CONDICIONALPARA  ::= pr_para CONTROLADOR SENTENCIA 
;


CONDICIONALSI  ::= pr_si CONDICIONAL BLOQUE 
;
CONDICIONALSI  ::= pr_si CONDICIONAL BLOQUE pr_sino BLOQUE 
;
CONDICIONALSI  ::= pr_si CONDICIONAL SENTENCIA 
;
CONDICIONALSI  ::= pr_si CONDICIONAL BLOQUE pr_sino SENTENCIA 
;
CONDICIONALSI  ::= pr_si CONDICIONAL SENTENCIA pr_sino BLOQUE 
;
CONDICIONALSI  ::= pr_si CONDICIONAL SENTENCIA pr_sino SENTENCIA 
;



CONTROLADOR  ::= par_ab INI punto_coma EXPGEN punto_coma ACT par_ce 
;


ESCRITURA  ::= pr_mostrar par_ab EXPGEN par_ce punto_coma 
;
ESCRITURA  ::= pr_mostrar par_ab cadena par_ce punto_coma 
;
ESCRITURA  ::= pr_mostrar par_ab par_ce punto_coma 
;

INDICE  ::= cor_ab EXPGEN:e cor_ce 
{:
    RESULT = e;
:};


INI  ::= id igual EXPGEN 
;
INI  ::= pr_entero id igual EXPGEN 
;


LECTURA  ::= pr_leer par_ab id par_ce punto_coma 
;



MATRIZ  ::= ll_ab NVECTOR ll_ce 
;

NVECTOR  ::= VECTOR 
;
NVECTOR  ::= VECTOR coma NVECTOR 
;

VECTOR  ::= ll_ab NELEMENTO ll_ce 
;

NELEMENTO  ::= EXPGEN 
;
NELEMENTO  ::= EXPGEN coma NELEMENTO 
;


DECLARACIONFUNCIONCABECERA  ::= TIPOVARIABLEFUNCION id par_ab PARAMETRO par_ce
;
DECLARACIONFUNCIONCABECERA  ::= TIPOVARIABLEFUNCION id par_ab par_ce
;

TIPOVARIABLEFUNCION  ::= TIPONUMERO 
;
TIPOVARIABLEFUNCION  ::= pr_vacio 
;

DEFINICIONVARIABLE  ::= DECLARACION DEFINICIONVARIABLE 
;
DEFINICIONVARIABLE  ::= DECLARACION
{:

:};



PARAMETRO  ::= TIPONUMERO id coma PARAMETRO 
;
PARAMETRO  ::= TIPONUMERO id INDICE coma PARAMETRO 
;
PARAMETRO  ::= TIPONUMERO id INDICE INDICE coma PARAMETRO 
;
PARAMETRO  ::= TIPONUMERO id INDICE INDICE 
;
PARAMETRO  ::= TIPONUMERO id INDICE 
;
PARAMETRO  ::= TIPONUMERO id 
;

PARAMETROBINARIO  ::= par_ab EXPGEN:e1 coma EXPGEN:e2 par_ce
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    param.add(e1);
    param.add(e2);
    RESULT = param;
:};

PARAMETROUNARIO  ::= par_ab EXPGEN:e1 par_ce  
{:
    ArrayList<Nodo> param = new ArrayList<Nodo>();
    param.add(e1);
    RESULT = param;
:};

SENTSELECTOR  ::= pr_selector CONDICIONAL ll_ab NCASO SENTDEFECTO ll_ce 
;
SENTSELECTOR  ::= pr_selector CONDICIONAL ll_ab NCASO ll_ce 
;

NCASO  ::= SENTCASO NCASO 
;
NCASO  ::= SENTCASO 
;

SENTCASO  ::= pr_caso numero sig_pun NSENTENCIA pr_saltar punto_coma 
;
SENTCASO  ::= pr_caso numero sig_pun pr_saltar punto_coma 
;
SENTCASO  ::= pr_caso numero sig_pun NSENTENCIA 
;
SENTCASO  ::= pr_caso numero sig_pun 
;



SENTDEFECTO  ::= pr_default sig_pun NSENTENCIA pr_saltar punto_coma  
;
SENTDEFECTO  ::= pr_default sig_pun pr_saltar punto_coma 
;



LLAMADAFUNCION  ::= id:i par_ab par_ce 
{:
    Nodo argumento = new Nodo(accion.argumento, accion.acciones[accion.argumento], 1, 1, (new ArrayList<Nodo>()), false);
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(argumento);
    RESULT = new Nodo(accion.llamadaFuncion, accion.acciones[accion.llamadaFuncion], 1, 1, hijos, false);
:};

LLAMADAFUNCION  ::= id:i par_ab ARGUMENTO:a par_ce 
{:
    Nodo argumento = new Nodo(accion.argumento, accion.acciones[accion.argumento], 1, 1, a, false);
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(argumento);
    RESULT = new Nodo(accion.llamadaFuncion, accion.acciones[accion.llamadaFuncion], 1, 1, hijos, false);
:};

OPERADORFUNCION  ::= pr_suma:op PARAMETROBINARIO:p
{:
    RESULT = new Nodo(accion.suma, accion.acciones[accion.suma], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_resta:op PARAMETROBINARIO:p
{:
    RESULT = new Nodo(accion.resta, accion.acciones[accion.resta], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_prod:op PARAMETROBINARIO:p
{:
    RESULT = new Nodo(accion.producto, accion.acciones[accion.producto], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_transp:op PARAMETROUNARIO:p
{:
    RESULT = new Nodo(accion.transpuesta, accion.acciones[accion.transpuesta], 1, 1, p,false);
:};

OPERADORFUNCION  ::= pr_inv:op PARAMETROUNARIO:p
{:
    RESULT = new Nodo(accion.inversa, accion.acciones[accion.inversa], 1, 1, p,false);
:};

OPERADORCOND  ::= CONDICIONAL sig_int EXPGEN sig_pun EXPGEN 
;


OPERADORASIGNACION  ::= a_div 
;
OPERADORASIGNACION  ::= a_prod 
;
OPERADORASIGNACION  ::= a_resta 
;
OPERADORASIGNACION  ::= a_suma 
;
OPERADORASIGNACION  ::= igual 
;
OPERADORASIGNACION  ::= a_mod 
;




OPERANDOENTERO  ::= LLAMADAFUNCION:ll
{:
    RESULT = ll;
:};

OPERANDOENTERO  ::= id:i INDICE:d1 INDICE:d2
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(d1);
    hijos.add(d2);
    RESULT = new Nodo(accion.accesoMat, accion.acciones[accion.accesoMat], 1, 1, hijos, false);
:};

OPERANDOENTERO  ::= id:i INDICE:d1
{:
    ArrayList<Nodo> hijos = new ArrayList<Nodo>();
    hijos.add(i);
    hijos.add(d1);
    RESULT = new Nodo(accion.accesoVec, accion.acciones[accion.accesoVec], 1, 1, hijos, false);
:};

OPERANDOENTERO  ::= id:i
{:
    RESULT = i;
:};

OPERANDOENTERO  ::= numero:n
{:
    RESULT = n;
:};

OPERADORPALABRABINARIO  ::= pr_suma:op
{:
    RESULT = op;
:};

OPERADORPALABRABINARIO  ::= pr_resta:op
{:
    RESULT = op;
:};

OPERADORPALABRABINARIO  ::= pr_prod:op
{:
    RESULT = op;
:};

OPERADORPALABRAUNARIO  ::= pr_transp:op
{:
    RESULT = op;
:};

OPERADORPALABRAUNARIO  ::= pr_inv:op
{:
    RESULT = op;
:};



OPERANDO  ::= OPERANDOENTERO:oe
{:
    RESULT = oe;
:};

OPERANDO  ::= real:r
{:
    RESULT = r;
:};

OPERANDO  ::= octa_e:o
{:
    RESULT = o;
:};

OPERANDO  ::= octa_r:o
{:
    RESULT = o;
:};

OPERANDO  ::= hexa_e:h
{:
    RESULT = h;
:};

OPERANDO  ::= hexa_r:h
{:
    RESULT = h;
:};


TIPONUMERO  ::= pr_entero 
;
TIPONUMERO  ::= pr_real 
;